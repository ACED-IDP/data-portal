

//----------------------------------------------

/**
 * App-aware GQLHelper - delegates to the appropriate helper for the given app
 * based on a compile-time transformation. Relay does not like gql that
 * does not conform to the schema supplied to the relay compiler, so to
 * support different dictionaries in the same app we need to be a little
 * bit clever. 
 */
export class GQLHelper {
  /**
   * Goofy little utility - scans data for keys matching 'fileCount\d+' or 'fileData\d+',
   * and returns a { fileCount: sum-of-fileCounts, fileData:[] concatenation of data }
   * 
   * @param {Object} data
   * @return {fileCount:sum,fileData:Array} 
   */
  static extractFileInfo( data ) {
    const fileCount = Object.keys( data ).filter( key => key.indexOf( "fileCount" ) === 0 ).map( key => data[key] 
    ).reduce( (acc,it) => acc + it, 0 );
    const fileData = Object.keys( data ).filter( key => key.indexOf( "fileData" ) === 0 ).map( key => data[key] 
    ).reduce( 
      (acc,it) => { let result=acc; if( Array.isArray( it ) ) { result = acc.concat( it ) } else { acc.push(it ); } return result }, 
      [] 
    );
    return { fileCount, fileData };
  }

  static extractFileDataToDict( data ) {
    return Object.keys( data ).filter( key => key.indexOf( "fileData" ) === 0 ).reduce(
      (acc,key) => {
        acc[key.substr(key.indexOf("_") + 1)] = data[key];
        return acc;
      },
      {}
    );
  }

  /**
   * Little singleton factory 
   */
  static getGQLHelper( appName=app ) {
    return helperSingleton;
  }

  static getExplorerVariables(selected_filters, pageSize, cursors) {
    return {
      {% for fType in fileTypeList %}firstValue_{{ fType }}: pageSize,
      cursor_{{ fType }}: ('{{ fType }}' in cursors) ? cursors['{{ fType }}'] : 0,
      {% endfor %}
      selected_projects: selected_filters ? selected_filters.projects : [],
      selected_file_formats: selected_filters ? selected_filters.file_formats: [],
      selected_file_types: selected_filters ? selected_filters.file_types : [],
    }
  }

  static getDefaultDictionary(data, cursors) {
    const fileLengthData = Object.keys( data ).filter( key => key.indexOf( "fileData" ) === 0 ).reduce(
      (map, key) => {
        map[key.substr(key.indexOf("_") + 1)] = data[key].length; return map;
      },
      {}
    );
    return Object.keys(fileLengthData).reduce(
      (map, key) => {
        if (key in cursors) {map[key] = cursors[key]}
        else {map[key] = 0}
        return map;
      }, {}
    );
  }

  static updateOffset(data, cursors) {
    const fileLengthData = Object.keys( data ).filter( key => key.indexOf( "fileData" ) === 0 ).reduce(
      (map, key) => {
        map[key.substr(key.indexOf("_") + 1)] = data[key].length; return map;
      },
      {}
    );
    return Object.keys(fileLengthData).reduce(
      (map, key) => {
        if (key in cursors) {map[key] = cursors[key] + fileLengthData[key]}
        else {map[key] = fileLengthData[key]}
        return map;
      }, {}
    );
  }
}


